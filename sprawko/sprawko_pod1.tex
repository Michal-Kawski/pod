\documentclass{classrep}
\usepackage[utf8]{inputenc}
\usepackage[pdftex]{graphicx}
\usepackage[polish]{babel}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{array}
\usepackage{multirow}
\usepackage{url}

\studycycle{Informatyka, studia dzienne, II st.}
\coursesemester{I}

\coursename{Przetwarzanie obrazów i dźwięków}
\courseyear{2010/2011}

\courseteacher{xxxxxx}
\coursegroup{xxxxxx}
\svnurl{xxxxxx}

\author{%
  \studentinfo{Michał Janiszewski}{169485} \and
  \studentinfo{Michał Kawski}{xxxxxx}
}

\title{Zadanie 1: Przetwarzanie obrazów}

\floatname{algorithm}{Algorytm}

\begin{document}

\maketitle

\section{Cel zadania}
Celem zadania było stworzenie szkieletu aplikacji do przetwarzania i analizy obrazów i dźwięków oraz zaimplementowanie następujących operacji dotyczących przetwarzania obrazu:
\begin{itemize}
 \item operacje podstawowe:
  \begin{itemize}
   \item zmiana kontrastu obrazu,
   \item zmiana jasności obrazu,
   \item wyznaczanie negatywu obrazu,
  \end{itemize}
 \item filtrowanie obrazu w oparciu o:
  \begin{itemize}
   \item filtr ze średnią arytmetyczną,
   \item filtr medianowy,
  \end{itemize}
 \item wyznaczanie i pokazywanie histogramu obrazu dla poszczególnych jego kanałów, a także umożliwienie edycji obrazu na podstawie tego histogramu,
 \item filtracja liniowa oparta o splot z możliwością zdefiniowania rozmiaru i wartości maski,
 \item filtracja nieliniowa w dziedzinie czasu.
\end{itemize}

Wylosowane warianty zadań to:
\begin{itemize}
 \item histogramy H3 \ppauza wyjściowa gęstość prawdopodobieństwa podana wzorem Raleigha:
  \begin{equation*}
   g(f) = g_{min} + \left(2 \alpha^2 \ln \left(\frac{1}{N} \displaystyle\sum\limits_{m=0}^f H\left(m\right)\right)^{-1}\right)^{\frac{1}{2}}
  \end{equation*}
 \item splot S4 \ppauza wydobywanie szczegółów z tła: południe, południowy-zachód, zachód, północny-zachód:
\begin{equation*}
\left(\begin{array}{ccc} -1 & -1 & -1 \\ 
1 & -2 & 1 \\
1 & 1 & 1 \\
\end{array}\right)\\
\\
\left(\begin{array}{ccc} 1 & -1 & -1 \\ 
1 & -2 & -1 \\
1 & 1 & 1 \\
\end{array}\right)\\
\\
\left(\begin{array}{ccc} 1 & 1 & -1 \\ 
1 & -2 & -1 \\
1 & 1 & -1 \\
\end{array}\right)\\
\\
\left(\begin{array}{ccc} 1 & 1 & 1 \\ 
1 & -2 & -1 \\
1 & -1 & -1 \\
\end{array}\right)
\end{equation*}
  \item filtracja nieliniowa O5 \ppauza operator Rosenfelda:
\begin{equation*}
 g(x, y) = \frac{1}{R} \left( \displaystyle \sum \limits_{i=1}^R f\left(x + i - 1, y\right) - \displaystyle \sum \limits_{i=1}^R f \left(x - i, y\right) \right)
\end{equation*}
\end{itemize}

\section{Opis metod przetwarzania}

Poniżej znajduje się opis algorytmów realizujących opisane powyżej zagadnienia. Obsługiwane są 3 typy obrazów:
\begin{enumerate}
 \item obrazy kolorowe (24-bitowe),
 \item obrazy w 8-bitowej skali szarości,
 \item obrazy binarne (1-bitowe).
\end{enumerate}

W przypadku obrazu kolorowego zakładamy, że każdy piksel ma trzy kanały: R (czerwony), G (zielony) i B (niebieski), a wartość każdego z tych pikseli znajduje się w zakresie $[0; 255]$ i przyjmuje tylko wartości całkowite.

W przypadku obrazów w skali szarości przyjmujemy, że każdy piksel posiada tylko jedną, 8-bitową składową, jest to indeks koloru z palety barw zapisanej w obrazie. Chociaż możliwe jest zapisanie dowolnej palety kolorów, przyjmujemy, że mamy do czynienia tylko i wyłącznie z obrazami w skali szarości (lub innego koloru), a 256 dostępnych, unikatowych kolorów w palecie uporządkowanych jest od najjaśniejszego (białego) do najbardziej intensywnego (czarnego \ppauza w przypadku skali szarości).

Piksele w obrazach binarnych przyjmują tylko dwa dostępne stany: biały i czarny.

Ponadto, przyjmijmy następujące oznaczenia:
\begin{description}
 \item[$g(n, m)$] wartość kanału piksela o współrzędnych $n, m$,
 \item[$N, M$] odpowiednio szerokość i wysokość obrazu w pikselach.
\end{description}


\subsection{Operacje podstawowe}

Opisane poniżej operacje podstawowe ograniczają swoje działanie tylko do jednego piksela, tzn. wartość funkcji przekształcenia nie zależy od otoczenia w jakim piksel się znajduje.

Algorytmy abstrachują od szczegółów implementacji, dzięki czemu można opisać ich działanie dla wszystkich wymienionych wyżej typów obrazów.

Ponieważ piksele w operacjach tych przetwarzane są niezależnie, przetwarzanie obrazu za ich pomocą sprowadza się do przetworzenia każdego piksela obrazu zadanym algorytmem.

\subsubsection{Negatyw}
Wyznaczanie negatywu obrazu sprowadza się do wyznacznia wartości przeciwnej dla każdego z kanałów piksela:

\begin{equation}
 g(n, m) = -g(n, m) \mod C_{max}
\end{equation}

gdzie $C_{max}$ to maksymalna możliwa wartość.

\subsubsection{Zmiana kontrastu}
Zmiana kontrastu to zmiana amplitudy charakteryzującej każdy z kanałów piksela. Dokonujemy tego poprzez mnożenie wartości każdego z kanałów przez pewien współczynnik $\alpha \in [0; 2]$, a następnie ograniczamy tak uzyskane wartości do zakresu możliwych:
\begin{equation}
 f(n, m) = g(n, m) \cdot \alpha
\end{equation}
\begin{equation}
 g(n, m) = \left\{
  \begin{array}{l l}
    0 & \quad f(n, m) < 0 \\
    f(n, m) & \quad 0 \leq f(n, m) \leq C_{max} \\
    C_{max} & \quad f(n, m) > C_{max} \\
  \end{array}
\right.
\end{equation}

\subsubsection{Zmiana jasności}
Zmiana jasności sprowadza się do dodania pewnej stałej $\delta$ do każdego kanału piksela. $\delta$ może przyjmować wartości zarówno dodatnie jak i ujemne, co określa odpowiednio rozjaśnianie oraz przyciemnianie obrazu. Tak przetworzone wartości należy ograniczyć jeszcze do wartości możliwych do zapisania w obrazie:
\begin{equation}
 f(n, m) = g(n, m) + \delta
\end{equation}
\begin{equation}
 g(n, m) = \left\{
  \begin{array}{l l}
    0 & \quad f(n, m) < 0 \\
    f(n, m) & \quad 0 \leq f(n, m) \leq C_{max} \\
    C_{max} & \quad f(n, m) > C_{max} \\
  \end{array}
\right.
\end{equation}

\subsection{Filtrowanie}
Filtrowanie obrazu jest próbą poprawienia jego jakości \ppauza zarówno obiektywnej jak i subiektywnej. Zadaniem zaimplementowanych filtrów jest usuwanie szumów z obrazu.

Każdy z tych filtrów, w odróżnieniu od operacji podstawowych, uwzględnia okolicę piksela, do której należy przetwarzany aktualnie piksel. Wielkość otoczenia nazywana jest wielkością maski i określa, ile pikseli zarówno w poziomie jak i pionie branych jest pod uwagę podczas wyliczania nowej wartości przetwarzanego piksela.

W przypadku gdy maska określa pobranie wartości piksela spoza obrazka, element taki zostaje zignorowany i nie jest brany pod uwagę w obliczeniach.

\subsubsection{Filtr ze średnią arytmetyczną}
Dla każdego kanału piksela obrazu sumowane są wartości tego kanału z wszystkich pikseli odległych od aktualnie przetwarzanego nie więcej, niż określa to rozmiar maski. Suma ta jest następnie dzielona przez ilość uwzględnionych elementów \ppauza obliczana jest średnia arytmetyczna:
\begin{equation}
 g(n, m) = \frac{1}{(2 \cdot w + 1) \cdot (2 \cdot h + 1)} \cdot \displaystyle \sum \limits_{n' = n - w}^{n + w} \displaystyle \sum \limits_{m' = m - h}^{m + h} g(n', m')
\end{equation}
gdzie $w$ to promień poziomy, a $h$ promień pionowy maski.

\subsubsection{Filtr medianowy}
W przypadku filtru medianowego wartości kanału ze wszystkich pikseli wchodzących w skład maski ustawiane są w niemalejącym szeregu, a następnie zwracana jest mediana tych elementów, czyli element z pozycji $\frac{l}{2}$~w~przypadku szeregu o nieparzystej długości $l$ lub średnia arytmetyczna z~dwóch środkowych elementów $\frac{g(\frac{l}{2} - 1) + g(\frac{l}{2})}{2}$ w przypadku szeregu o parzystej ilości elementów.

\subsection{Modyfikacja w oparciu o histogram}

\subsection{Filtracja liniowa w oparciu o splot}
Aby dokonać filtracji liniowej opartej o splot, konieczna jest znajomość maski filtru, jaka opisuje odpowiedź impulsową splotu. Nazwijmy tę maskę macierzą $X[2 \cdot W + 1; 2 \cdot H + 1]$ i przyjmijmy, że funkcja $x(w, h)$ zwraca element macierzy $X$ z pozycji $(w, h)$, wtedy:
\begin{equation}
 g(n, m) = \displaystyle \sum \limits_{w=-W}^W \displaystyle \sum \limits_{h=-H}^H g(n + w, m + h) \cdot x(w, h)
\end{equation}

Uzyskane w taki sposób wartości należy znormalizować. W tym celu postanowiliśmy znaleźć minimalną i maksymalną wartość kanału $C'_{min}$ oraz $C'_{max}$ po przekształceniu, a następnie przeskalować wszystkie wartości z tego zakresu na zakres możliwy do osiągnięcia $C_{min} \div C_{max}$\footnote{Wartość $C_{min}$ wynosi 0, zatem można ją pominąć w obliczeniach}:
\begin{equation}
 c = \frac{C_{max}}{C'_{max} - C'_{min}} \cdot (c' - C'_{min})
\end{equation}


\begin{thebibliography}{99}
%\bibitem{pleple}
% opis
\end{thebibliography}

\end{document}
