\documentclass{classrep}
\usepackage[utf8]{inputenc}
\usepackage[pdftex]{graphicx}
\usepackage[polish]{babel}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{array}
\usepackage{multirow}
\usepackage{url}

\studycycle{Informatyka, studia dzienne, II st.}
\coursesemester{I}

\coursename{Przetwarzanie obrazów i dźwięków}
\courseyear{2010/2011}

\courseteacher{xxxxxx}
\coursegroup{xxxxxx}
\svnurl{xxxxxx}

\author{%
  \studentinfo{Michał Janiszewski}{169485} \and
  \studentinfo{Michał Kawski}{xxxxxx}
}

\title{Zadanie 1: Przetwarzanie obrazów}

\floatname{algorithm}{Algorytm}

\begin{document}

\maketitle

\section{Cel zadania}
Celem zadania było stworzenie szkieletu aplikacji do przetwarzania i analizy obrazów i dźwięków oraz zaimplementowanie następujących operacji dotyczących przetwarzania obrazu:
\begin{itemize}
 \item operacje podstawowe:
  \begin{itemize}
   \item zmiana kontrastu obrazu,
   \item zmiana jasności obrazu,
   \item wyznaczanie negatywu obrazu,
  \end{itemize}
 \item filtrowanie obrazu w oparciu o:
  \begin{itemize}
   \item filtr ze średnią arytmetyczną,
   \item filtr medianowy,
  \end{itemize}
 \item wyznaczanie i pokazywanie histogramu obrazu dla poszczególnych jego kanałów, a także umożliwienie edycji obrazu na podstawie tego histogramu,
 \item filtracja liniowa oparta o splot z możliwością zdefiniowania rozmiaru i wartości maski,
 \item filtracja nieliniowa w dziedzinie czasu.
\end{itemize}

Wylosowane warianty zadań to:
\begin{itemize}
 \item histogramy H3 \ppauza wyjściowa gęstość prawdopodobieństwa podana wzorem Raleigha:
  \begin{equation*}
   g(f) = g_{min} + \left(2 \alpha^2 \ln \left(\frac{1}{N} \displaystyle\sum\limits_{m=0}^f H\left(m\right)\right)^{-1}\right)^{\frac{1}{2}}
  \end{equation*}
 \item splot S4 \ppauza wydobywanie szczegółów z tła: południe, południowy-zachód, zachód, północny-zachód:
\begin{equation*}
\left(\begin{array}{ccc} -1 & -1 & -1 \\ 
1 & -2 & 1 \\
1 & 1 & 1 \\
\end{array}\right)\\
\\
\left(\begin{array}{ccc} 1 & -1 & -1 \\ 
1 & -2 & -1 \\
1 & 1 & 1 \\
\end{array}\right)\\
\\
\left(\begin{array}{ccc} 1 & 1 & -1 \\ 
1 & -2 & -1 \\
1 & 1 & -1 \\
\end{array}\right)\\
\\
\left(\begin{array}{ccc} 1 & 1 & 1 \\ 
1 & -2 & -1 \\
1 & -1 & -1 \\
\end{array}\right)
\end{equation*}
  \item filtracja nieliniowa O5 \ppauza operator Rosenfelda:
\begin{equation*}
 g(x, y) = \frac{1}{R} \left( \displaystyle \sum \limits_{i=1}^R f\left(x + i - 1, y\right) - \displaystyle \sum \limits_{i=1}^R f \left(x - i, y\right) \right)
\end{equation*}
\end{itemize}

\section{Opis metod przetwarzania}

Poniżej znajduje się opis algorytmów realizujących opisane powyżej zagadnienia. Obsługiwane są 3 typy obrazów:
\begin{enumerate}
 \item obrazy kolorowe (24-bitowe),
 \item obrazy w 8-bitowej skali szarości,
 \item obrazy binarne (1-bitowe).
\end{enumerate}

W przypadku obrazu kolorowego zakładamy, że każdy piksel ma trzy kanały: R (czerwony), G (zielony) i B (niebieski), a wartość każdego z tych pikseli znajduje się w zakresie $[0; 255]$ i przyjmuje tylko wartości całkowite.

W przypadku obrazów w skali szarości przyjmujemy, że każdy piksel posiada tylko jedną, 8-bitową składową, jest to indeks koloru z palety barw zapisanej w obrazie. Chociaż możliwe jest zapisanie dowolnej palety kolorów, przyjmujemy, że mamy do czynienia tylko i wyłącznie z obrazami w skali szarości (lub innego koloru), a 256 dostępnych, unikatowych kolorów w palecie uporządkowanych jest od najjaśniejszego (białego) do najbardziej intensywnego (czarnego \ppauza w przypadku skali szarości).

Piksele w obrazach binarnych przyjmują tylko dwa dostępne stany: biały i czarny.

Ponadto, przyjmijmy następujące oznaczenia:
\begin{description}
 \item[$g(n, m)$] wartość kanału piksela o współrzędnych $n, m$,
 \item[$N, M$] odpowiednio szerokość i wysokość obrazu w pikselach.
\end{description}


\subsection{Operacje podstawowe}

Opisane poniżej operacje podstawowe ograniczają swoje działanie tylko do jednego piksela, tzn. wartość funkcji przekształcenia nie zależy od otoczenia w jakim piksel się znajduje.

Algorytmy abstrachują od szczegółów implementacji, dzięki czemu można opisać ich działanie dla wszystkich wymienionych wyżej typów obrazów.

Ponieważ piksele w operacjach tych przetwarzane są niezależnie, przetwarzanie obrazu za ich pomocą sprowadza się do przetworzenia każdego piksela obrazu zadanym algorytmem.

\subsubsection{Negatyw}
Wyznaczanie negatywu obrazu sprowadza się do wyznacznia wartości przeciwnej dla każdego z kanałów piksela:

\begin{equation}
 g(n, m) = -g(n, m) \mod C_{max}
\end{equation}

gdzie $C_{max}$ to maksymalna możliwa wartość.

\subsubsection{Zmiana kontrastu}
Zmiana kontrastu to zmiana amplitudy charakteryzującej każdy z kanałów piksela. Dokonujemy tego poprzez mnożenie wartości każdego z kanałów przez pewien współczynnik $\alpha \in [0; 2]$, a następnie ograniczamy tak uzyskane wartości do zakresu możliwych:
\begin{equation}
 f(n, m) = g(n, m) \cdot \alpha
\end{equation}
\begin{equation}
 g(n, m) = \left\{
  \begin{array}{l l}
    0 & \quad f(n, m) < 0 \\
    f(n, m) & \quad 0 \leq f(n, m) \leq C_{max} \\
    C_{max} & \quad f(n, m) > C_{max} \\
  \end{array}
\right.
\end{equation}

\subsubsection{Zmiana jasności}
Zmiana jasności sprowadza się do dodania pewnej stałej $\delta$ do każdego kanału piksela. $\delta$ może przyjmować wartości zarówno dodatnie jak i ujemne, co określa odpowiednio rozjaśnianie oraz przyciemnianie obrazu. Tak przetworzone wartości należy ograniczyć jeszcze do wartości możliwych do zapisania w obrazie:
\begin{equation}
 f(n, m) = g(n, m) + \delta
\end{equation}
\begin{equation}
 g(n, m) = \left\{
  \begin{array}{l l}
    0 & \quad f(n, m) < 0 \\
    f(n, m) & \quad 0 \leq f(n, m) \leq C_{max} \\
    C_{max} & \quad f(n, m) > C_{max} \\
  \end{array}
\right.
\end{equation}

\begin{thebibliography}{99}
%\bibitem{pleple}
% opis
\end{thebibliography}

\end{document}
